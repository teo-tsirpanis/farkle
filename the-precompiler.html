<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Farkle's precompiler
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="A modern and easy-to-use parser library for F#"/>
    <meta name="author" content="Theodore Tsirpanis"/>

    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js" async></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
    <link href="https://stackpath.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet" integrity="sha384-4FeI0trTH/PCsLWrGCD1mScoFu9Jf2NdknFdFoJhXZFwsvzZ3Bo5sAh7+zL8Xgnd" crossorigin="anonymous">

    <link type="text/css" rel="stylesheet" href="/Farkle/content/style.css" />
    <script type="text/javascript" src="/Farkle/content/tips.js" async></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="https://github.com/teo-tsirpanis/Farkle">github page</a></li>
        </ul>
        <h3 class="muted"><a href="/Farkle/index.html">Farkle</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          <h1><a name="Farkle-s-precompiler" class="anchor" href="#Farkle-s-precompiler">Farkle's precompiler</a></h1>
<p>Every time an app using Farkle starts, it generates the parser tables for its grammars. This process takes some time, and it take even more, if the app does not reuse the runtime Farkles it creates.</p>
<p>Most apps need to parse a static grammar whose specification never changes between program executions. For example, a compiler or a JSON parsing library will parse text from the same language every time you use them. Farkle would spend time generating these parsing tables that do not depend on user input and will always be the same. It wouldn't hurt a program like a REST API server parsing lots of input strings, but for a compiler that parses only one file, building that grammar every time it is executed would impose an unnecessary overhead, maybe more than the time spent for the rest of the program, if the grammar is big.</p>
<p>What is more, Farkle does not report any grammar error (such as an LALR conflict) until it's too late: text was attempted to be parsed with a faulty grammar. Wouldn't it be better if these errors were caught earlier in the app's developemnt lifecycle?</p>
<p>One of Farkle's new features that came with version 6 is called <em>the precompiler</em>. The precompiler addresses this inherent limitation of Farkle's grammars being objects defined in code. Instead of building them every time, the grammar's parser tables are built <em>ahead of time</em> and stored in the program's assembly when it gets compiled. When that program is executed, instead of building the parser tables, it loads the precompiled grammar from the assembly, which is orders of magnitude faster.</p>
<blockquote>
<p><a href="#Building-from-an-IDE"><strong>Using the precompiler with Visual Studio for Windows is not currently supported.</strong></a></p>
</blockquote>
<h2><a name="How-to-use-it" class="anchor" href="#How-to-use-it">How to use it</a></h2>
<p>Using the precompiler does not differ very much from regularly using Farkle.</p>
<h3><a name="Preparing-the-your-code" class="anchor" href="#Preparing-the-your-code">Preparing the your code</a></h3>
<p>In F# designtime Farkles can be marked to be precompiled by applying the <code>RuntimeFarkle.markForPrecompile</code> function at the end. To build them, instead of using <code>RuntimeFarkle.build</code>, you have to use <code>RuntimeFarkle.buildPrecompiled</code> like in the example:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">Farkle</span>
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 2)" onmouseover="showTip(event, 'fs1', 2)" class="id">Farkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs2', 3)" onmouseover="showTip(event, 'fs2', 3)" class="id">Builder</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs3', 4)" onmouseover="showTip(event, 'fs3', 4)" class="id">precompilableDesigntime</span> <span class="o">=</span>
    <span class="s">&quot;My complicated language&quot;</span>
    <span class="o">||=</span> <span class="pn">[</span><span class="o">!@</span> <span class="id">beginning</span> <span class="o">.</span><span class="o">&gt;&gt;.</span> <span class="id">middle</span> <span class="o">.</span><span class="o">&gt;&gt;.</span> <span class="id">``end``</span> <span class="o">=&gt;</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs4', 5)" onmouseover="showTip(event, 'fs4', 5)" class="id">b</span> <span onmouseout="hideTip(event, 'fs5', 6)" onmouseover="showTip(event, 'fs5', 6)" class="id">m</span> <span onmouseout="hideTip(event, 'fs6', 7)" onmouseover="showTip(event, 'fs6', 7)" class="id">e</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs4', 8)" onmouseover="showTip(event, 'fs4', 8)" class="id">b</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs5', 9)" onmouseover="showTip(event, 'fs5', 9)" class="id">m</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs6', 10)" onmouseover="showTip(event, 'fs6', 10)" class="id">e</span><span class="pn">)</span><span class="pn">]</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 11)" onmouseover="showTip(event, 'fs7', 11)" class="m">DesigntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs8', 12)" onmouseover="showTip(event, 'fs8', 12)" class="id">addLineComment</span> <span class="s">&quot;//&quot;</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 13)" onmouseover="showTip(event, 'fs7', 13)" class="m">DesigntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs9', 14)" onmouseover="showTip(event, 'fs9', 14)" class="id">addBlockComment</span> <span class="s">&quot;/*&quot;</span> <span class="s">&quot;*/&quot;</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 15)" onmouseover="showTip(event, 'fs10', 15)" class="m">RuntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs11', 16)" onmouseover="showTip(event, 'fs11', 16)" class="id">markForPrecompile</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 17)" onmouseover="showTip(event, 'fs12', 17)" class="id">runtime</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs10', 18)" onmouseover="showTip(event, 'fs10', 18)" class="m">RuntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs13', 19)" onmouseover="showTip(event, 'fs13', 19)" class="id">buildPrecompiled</span> <span onmouseout="hideTip(event, 'fs3', 20)" onmouseover="showTip(event, 'fs3', 20)" class="id">precompilableDesigntime</span>
</code></pre></td>
</tr>
</table>
<p>Untyped designtime Farkles can be marked for precompilation with the <code>markForPrecompileU</code> function and can be built using the <code>RuntimeFarkle.buildPrecompiledUntyped</code> function.</p>
<hr />
<p>In C# you have to call the <code>MarkForPrecompile</code> extension method and store its result in a field of type <code>PrecompilableDesigntimeFarkle</code> like the example:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="csharp"><span class="k">using</span> Farkle;
<span class="k">using</span> Farkle.Builder;

<span class="k">public</span> <span class="k">class</span> MyLanguage {
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> PrecompilableDesigntimeFarkle&lt;<span class="k">int</span>&gt; Designtime;
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> RuntimeFarkle&lt;<span class="k">int</span>&gt; Runtime;

    <span class="k">static</span> MyLanguage() {
        Designtime <span class="o">=</span>
            Nonterminal.Create(<span class="s">"My complicated language"</span>,
                beginning.Extended().Extend(middle).Extend(end).Finish((b, m, e) <span class="o">=</span><span class="o">&gt;</span> b <span class="o">+</span> m <span class="o">+</span> e))
            .AddLineComment(<span class="s">"//"</span>)
            .AddBlockComment(<span class="s">"/*"</span>, <span class="s">"*/"</span>)
            .MarkForPrecompile();

        Runtime <span class="o">=</span> Designtime.Build();
    }
}
</code></pre></td></tr></table>
<p>As you see, the building methods in C# have the same name as before. The type for untyped precompilable designime Farkles is <code>PrecompilableDesigntimeFarkle</code>, without a type parameter.</p>
<h3><a name="The-rules" class="anchor" href="#The-rules">The rules</a></h3>
<p>A precompilable designtime Farkle will be discovered and precompiled if it is declared in a <code>static readonly</code> <em>field</em> (not property). In F#, a let-bound value in a module is equivalent, but it must not be mutable. Also, <code>static let</code>s in class declarations will not be recognized because they are not compiled as <code>readonly</code>.</p>
<p>This field can be of any visibility; public, internal, private, it doesn't matter. It will be detected even in nested classes or nested F# modules. It <em>cannot</em> however be declared in a generic type.</p>
<p>In addition, the precompilable designtime Farkle must be marked in the assembly it is declared. Let's see a counterexample:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="csharp"><span class="c">// Assembly A</span>
<span class="k">public</span> <span class="k">class</span> AssemblyA {
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> PrecompilableDesigntimeFarkle&lt;<span class="k">int</span>&gt; Designtime;

    <span class="k">static</span> AssemblyA() {
        Designtime <span class="o">=</span>
            <span class="c">// ...</span>
            .MarkForPrecompile();
    }
}

<span class="c">// Assembly B</span>
<span class="k">public</span> <span class="k">class</span> AssemblyB {
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> PrecompilableDesigntimeFarkle&lt;<span class="k">int</span>&gt; WillNotBePrecompiled <span class="o">=</span>
        AssemblyA.Designtime;

    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> PrecompilableDesigntimeFarkle&lt;<span class="k">int</span>&gt; WillBePrecompiled <span class="o">=</span>
        AssemblyA.Designtime.InnerDesigntimeFarkle.MarkForPrecompile();
}
</code></pre></td></tr></table>
<p>The precompiler will raise warnings to help you abide by the rules above.</p>
<p>Furthermore, all precompilable designtime Farkles within an assembly must have different names, or an error will be raised during precompiling. You can use the <code>DesigntimeFarkle.rename</code> function or the <code>Rename</code> extension method to rename a designtime Farkle before marking it as precompilable.</p>
<p>Multiple field references to the same precompilable designtime Farkle do not pose a problem and will be precompiled only once.</p>
<h3><a name="Preparing-your-project" class="anchor" href="#Preparing-your-project">Preparing your project</a></h3>
<p>With your designtime Farkles being ready to be precompiled, it's time to prepare your project file. Add a reference to <a href="https://www.nuget.org/packages/Farkle.Tools.MSBuild">the <code>Farkle.Tools.MSBuild</code> package</a> like that:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="xml"><span class="k">&lt;</span><span class="i">ItemGroup</span><span class="k">&gt;</span>
    <span class="k">&lt;</span><span class="i">PackageReference</span> <span class="o">Include</span><span class="k">="Farkle"</span> <span class="o">Version</span><span class="k">="6.*"</span> <span class="k">/&gt;</span>
    <span class="k">&lt;</span><span class="i">PackageReference</span> <span class="o">Include</span><span class="k">="Farkle.Tools.MSBuild"</span> <span class="o">Version</span><span class="k">="6.*"</span> <span class="o">PrivateAssets</span><span class="k">="all"</span> <span class="k">/&gt;</span>
<span class="k">&lt;/</span><span class="i">ItemGroup</span><span class="k">&gt;</span>
</code></pre></td></tr></table>
<blockquote>
<p><strong>Important:</strong> The packages <code>Farkle</code> and <code>Farkle.Tools.MSBuild</code> must be at the same version.</p>
</blockquote>
<p>If you build your program now, you should get a message that your designtime Farkles' grammars got precompiled. Hooray! Your app's startup time will be now much faster.</p>
<p><strong>If you have marked your designtime Farkles as precompiled, using the precompiler is mandatory.</strong> Parsing will always eventually fail if you build a precompilable designtime Farkle without having used the precompiler.</p>
<h2><a name="Customizing-the-precompiler" class="anchor" href="#Customizing-the-precompiler">Customizing the precompiler</a></h2>
<p>The precompiler's behavior can be customized by the following MSBuild properties you can set in your project file:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="xml"><span class="k">&lt;</span><span class="i">PropertyGroup</span><span class="k">&gt;</span>
    <span class="c">&lt;!-- Set it to false to disable the precompiler. As stated above however,</span>
<span class="c">    disabling it will cause parsing these precompiled grammars to fail. --&gt;</span>
    <span class="k">&lt;</span><span class="i">FarkleEnablePrecompiler</span><span class="k">&gt;</span>false<span class="k">&lt;/</span><span class="i">FarkleEnablePrecompiler</span><span class="k">&gt;</span>
    <span class="c">&lt;!-- If set to true, Farkle will generate an HTML page</span>
<span class="c">    describing each precompiled grammar. Defaults to false. --&gt;</span>
    <span class="k">&lt;</span><span class="i">FarkleGenerateHtml</span><span class="k">&gt;</span>true<span class="k">&lt;/</span><span class="i">FarkleGenerateHtml</span><span class="k">&gt;</span>
<span class="k">&lt;/</span><span class="i">PropertyGroup</span><span class="k">&gt;</span>
</code></pre></td></tr></table>
<p>The <code>FarkleGenerateHtml</code> property uses Farkle's templating engine which is described <a href="templates.html#Creating-HTML-Pages">in its own page</a>.</p>
<p>Furthermore, Farkle's precompiler is based on <a href="https://github.com/teo-tsirpanis/Sigourney">Sigourney</a>, which can be globally disabled by setting the <code>SigourneyEnable</code> property to false.</p>
<h2><a name="Some-final-notes" class="anchor" href="#Some-final-notes">Some final notes</a></h2>
<h3><a name="Composability" class="anchor" href="#Composability">Composability</a></h3>
<p>The name "precompilable designtime Farkle" is a bit misleading, because these objects do not implement the <code>DesigntimeFarkle</code> interface. This means that you cannot compose a precompilable designtime Farkle to form a bigger grammar, as you can do with an actual designtime Farkle. This incompatibility ensures that you are using the <code>markForPrecompile</code> family of functions correctly, by applying them once at the end.</p>
<p>To get the actual designtime Farkle behind a precompilable one, you have to use the <code>InnerDesigntimeFarkle</code> property:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs14', 21)" onmouseover="showTip(event, 'fs14', 21)" class="id">composable</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 22)" onmouseover="showTip(event, 'fs3', 22)" class="id">precompilableDesigntime</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs15', 23)" onmouseover="showTip(event, 'fs15', 23)" class="id">InnerDesigntimeFarkle</span>
</code></pre></td>
</tr>
</table>
<h3><a name="Beware-of-code-execution" class="anchor" href="#Beware-of-code-execution">Beware of code execution</a></h3>
<p>Farkle's precompiler executes part of your project's code; the necessary static constructors to create your precompilable designtime Farkles. This code can do literally anything, but it is your responsibility to keep it short and without adverse side-effects. Similarly, it is your responsibility to not build untrusted projects that use the precompiler. Consuming 3rd-party libraries with precompiled grammars however will not execute arbitrary code on build.</p>
<h3><a name="Beware-of-non-determinism" class="anchor" href="#Beware-of-non-determinism">Beware of non-determinism</a></h3>
<p>Farkle's precompiler was made for grammars that are fixed, which is the reason it only works on static readonly fields: once you created it in your code, you cannot change it. Otherwise, what good would the precompiler be?</p>
<p>You can always call a non-deterministic function like <code>DateTime.Now</code> that will make your designtime Farkle parse integers in the hexadecimal format in your birthday, and in the decimal format in all other days. If you build your app on your birthday, it will produce bizarre results on all the other days, and if you build it on a day other than your birthday, it will work every time, except on your birthday (the worst birthday present). <strong>Just don't do it.</strong> Farkle cannot be made to detect such things, and you are not getting any smarter by doing it.</p>
<h3><a name="Building-from-an-IDE" class="anchor" href="#Building-from-an-IDE">Building from an IDE</a></h3>
<p>And last but not least, the precompiler will not work when running a .NET Framework-based edition of MSBuild. This includes building from Visual Studio for Windows. The recommended way to build an app that uses the precompiler is through <code>dotnet build</code> and its friends. <a href="https://developercommunity2.visualstudio.com/t/Allow-building-SDK-style-projects-with-t/1331985">A suggestion on Visual Studio Developer Community</a> has been filed that would solve the problem but it won't be implemented anytime soon.</p>
<p>This doesn't mean that the precompiler won't work on .NET Framework assemblies; you have to use the SDK-style project format and build with the .NET Core SDK; it will normally work.</p>
<blockquote>
<p><strong>Note</strong>: Precompiling a .NET Framework assembly will load it to the .NET Core-based precompiler. While it sometimes works due to a .NET Core compatibility shim, don't hold your breath that it will always work and you'd better not precompile designtime Farkles in assemblies that use .NET Framework-only features. It might work, it might fail, who knows? And why are you still using the .NET Framework?</p>
</blockquote>
<p>Rider however <em>can</em> use the precompiler with a simple workaround. Open its settings, go to "Build, Execution, Deployment", "Toolset and Build", "Use MSBuild version", and select an MSBuild executable from the .NET Core SDK (it typically has a <code>.dll</code> extension).</p>
<p><img src="img/rider_msbuild_workaround.png" alt="The Settings window in JetBrains Rider" /></p>
<hr />
<p>So I hope you enjoyed this little tutorial. If you did, don't forget to give Farkle a try, and maybe you feel especially precompiled today, and want to hit the star button as well. I hope that all of you have an wonderful day, and to see you soon. Goodbye!</p>

<div class="tip" id="fs1">namespace Farkle</div>
<div class="tip" id="fs2">namespace Farkle.Builder</div>
<div class="tip" id="fs3">val precompilableDesigntime : PrecompilableDesigntimeFarkle&lt;int&gt;</div>
<div class="tip" id="fs4">val b : int</div>
<div class="tip" id="fs5">val m : int</div>
<div class="tip" id="fs6">val e : int</div>
<div class="tip" id="fs7">Multiple items<br />module DesigntimeFarkle<br /><br />from Farkle.Builder<br /><br />--------------------<br />type DesigntimeFarkle =<br />&#160;&#160;interface<br />&#160;&#160;&#160;&#160;abstract member Metadata : GrammarMetadata<br />&#160;&#160;&#160;&#160;abstract member Name : string<br />&#160;&#160;end<br /><br />--------------------<br />type DesigntimeFarkle&lt;&#39;T&gt; =<br />&#160;&#160;interface<br />&#160;&#160;&#160;&#160;inherit DesigntimeFarkle<br />&#160;&#160;end</div>
<div class="tip" id="fs8">val addLineComment : commentStart:string -&gt; df:DesigntimeFarkle&lt;&#39;a&gt; -&gt; DesigntimeFarkle&lt;&#39;a&gt;</div>
<div class="tip" id="fs9">val addBlockComment : commentStart:string -&gt; commentEnd:string -&gt; df:DesigntimeFarkle&lt;&#39;a&gt; -&gt; DesigntimeFarkle&lt;&#39;a&gt;</div>
<div class="tip" id="fs10">Multiple items<br />module RuntimeFarkle<br /><br />from Farkle<br /><br />--------------------<br />type RuntimeFarkle&lt;&#39;TResult&gt; =<br />&#160;&#160;private { Grammar: Result&lt;Grammar,BuildError list&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PostProcessor: PostProcessor&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;TokenizerFactory: TokenizerFactory }<br />&#160;&#160;&#160;&#160;interface IGrammarProvider<br />&#160;&#160;&#160;&#160;member Cast : unit -&gt; RuntimeFarkle&lt;obj&gt;<br />&#160;&#160;&#160;&#160;member ChangePostProcessor : pp:PostProcessor&lt;&#39;TNewResult&gt; -&gt; RuntimeFarkle&lt;&#39;TNewResult&gt;<br />&#160;&#160;&#160;&#160;member ChangeTokenizer : unit -&gt; RuntimeFarkle&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;&#160;member ChangeTokenizer : tokenizerFactory:TokenizerFactory -&gt; RuntimeFarkle&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;&#160;member GetBuildErrorMessage : unit -&gt; string<br />&#160;&#160;&#160;&#160;member GetBuildErrors : unit -&gt; BuildError list<br />&#160;&#160;&#160;&#160;member GetGrammar : unit -&gt; Grammar<br />&#160;&#160;&#160;&#160;member Parse : textReader:TextReader -&gt; Result&lt;&#39;TResult,FarkleError&gt;<br />&#160;&#160;&#160;&#160;member Parse : inputString:string -&gt; Result&lt;&#39;TResult,FarkleError&gt;<br />&#160;&#160;&#160;&#160;...</div>
<div class="tip" id="fs11">val markForPrecompile : df:DesigntimeFarkle&lt;&#39;a&gt; -&gt; PrecompilableDesigntimeFarkle&lt;&#39;a&gt;</div>
<div class="tip" id="fs12">val runtime : RuntimeFarkle&lt;int&gt;</div>
<div class="tip" id="fs13">val buildPrecompiled : pcdf:PrecompilableDesigntimeFarkle&lt;&#39;a&gt; -&gt; RuntimeFarkle&lt;&#39;a&gt;</div>
<div class="tip" id="fs14">val composable : DesigntimeFarkle&lt;int&gt;</div>
<div class="tip" id="fs15">property PrecompilableDesigntimeFarkle.InnerDesigntimeFarkle: DesigntimeFarkle&lt;int&gt; with get</div>

        </div>
        <div class="span3">
          <img src="/Farkle/img/logo.png" alt="F# Project" style="width:150px;margin:10px" />
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">Farkle</li>
            <li><a href="/Farkle/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="https://nuget.org/packages/Farkle">Get Library via NuGet</a></li>
            <li><a href="https://github.com/teo-tsirpanis/Farkle">Source Code on GitHub</a></li>
            <li><a href="/Farkle/license.html">License</a></li>
            <li><a href="/Farkle/release-notes.html">Release Notes</a></li>
            <li><a href="/Farkle/choosing-a-parser.html">Choosing a parser: Farkle vs alternatives</a></li>

            <li class="nav-header">Getting started</li>
            <li><a href="/Farkle/quickstart.html">Quick Start with F#</a></li>
            <li><a href="/Farkle/csharp.html">Using Farkle with C#</a></li>

            <li class="nav-header">Documentation</li>
            <li><a href="/Farkle/reference/index.html">API Reference</a></li>
            <li><a href="/Farkle/templates.html">Templating Reference</a></li>
            <li><a href="/Farkle/string-regexes.html">String regex reference</a></li>
            <li><a href="/Farkle/the-precompiler.html">The precompiler</a></li>
            <li><a href="/Farkle/advanced-features.html">Advanced Features</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="https://github.com/teo-tsirpanis/Farkle" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  </body>
</html>
