<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Advanced features
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="A modern and easy-to-use parser library for F#"/>
    <meta name="author" content="Theodore Tsirpanis"/>

    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js" async></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
    <link href="https://stackpath.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet" integrity="sha384-4FeI0trTH/PCsLWrGCD1mScoFu9Jf2NdknFdFoJhXZFwsvzZ3Bo5sAh7+zL8Xgnd" crossorigin="anonymous">

    <link type="text/css" rel="stylesheet" href="/Farkle/content/style.css" />
    <script type="text/javascript" src="/Farkle/content/tips.js" async></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="https://github.com/teo-tsirpanis/Farkle">github page</a></li>
        </ul>
        <h3 class="muted"><a href="/Farkle/index.html">Farkle</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          <h1><a name="Advanced-features" class="anchor" href="#Advanced-features">Advanced features</a></h1>
<p>Farkle has a couple of features that were not covered in other guides because they are less likely to be useful. In this guide, we will take a look at some of these features that truly push Farkle's capabilities to the fullest. So, are you ready? Let's do this!</p>
<h2><a name="The-untyped-API" class="anchor" href="#The-untyped-API">The untyped API</a></h2>
<p>The first feature we are going to discuss is a different API for creating grammars, which is called the untyped API. Usually, when we write our designtime Farkles, we do not only state how our grammar is structured, but also what should our parser do when he encounters a specific symbol. There are times however that we do not want to do the latter thing: we just want Farkle to create a grammar. Let's take a look at the following grammar which matches matching parentheses:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">&lt;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="o">::</span><span class="o">=</span> <span class="pn">&lt;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="pn">(</span> <span class="pn">&lt;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="pn">)</span>
<span class="pn">&lt;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="o">::</span><span class="o">=</span> <span class="o">&lt;&gt;</span>
</code></pre></td>
</tr>
</table>
<p>In Farkle, one way to write this grammar, is to just write it, but return dummy types like units on every production:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// In all our examples, we always open this namespace.</span>
<span class="k">open</span> <span class="id">Farkle</span><span class="pn">.</span><span class="id">Builder</span>

<span class="k">let</span> <span class="id">S</span> <span class="o">=</span> <span class="id">nonterminal</span> <span class="s">&quot;S&quot;</span>

<span class="id">S</span><span class="pn">.</span><span class="id">SetProductions</span><span class="pn">(</span>
    <span class="o">!%</span> <span class="id">S</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;(&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="id">S</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;)&quot;</span> <span class="o">=%</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">,</span>
    <span class="id">empty</span> <span class="o">=%</span> <span class="pn">(</span><span class="pn">)</span>
<span class="pn">)</span>
</code></pre></td>
</tr>
</table>
<p>On larger grammars however, this habit of adding <code>=% ()</code> to the end of each production tends to be repetitive. Also imagine if we had more complex terminals. We would have done something like this:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">X</span> <span class="o">=</span>
    <span class="id">myComplexRegex</span>
    <span class="o">|&gt;</span> <span class="id">terminal</span> <span class="s">&quot;X&quot;</span> <span class="pn">(</span><span class="id">T</span><span class="pn">(</span><span class="k">fun</span> <span class="id">_</span> <span class="id">_</span> <span class="k">-&gt;</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span>
</code></pre></td>
</tr>
</table>
<p>The parentheses-ridden delegate definition at the end would have to be repeated, for every terminal we would have to create.</p>
<p>For this reason, the untyped API was created, to minimize code duplication. Let's first see how we would write our terminal:</p>
<p><strong>F#:</strong></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">X</span> <span class="o">=</span>
    <span class="id">myComplexRegex</span>
    <span class="o">|&gt;</span> <span class="id">terminalU</span> <span class="s">&quot;X&quot;</span>
</code></pre></td>
</tr>
</table>
<p><strong>C#:</strong></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">DesigntimeFarkle X <span class="o">=</span> Terminal.Create(<span class="s">"X"</span>, myComplexRegex);
</code></pre></td></tr></table>
<p>In F#, we use the <code>terminalU</code> function (guess what the U stands for), and in C# we just omit the delegate (it would have otherwise appeared between the name and the regex).</p>
<p>As you might have seen, the terminal is of type <code>DesigntimeFarkle</code>, without a generic parameter at the end. This means it can be normally used from other grammars (even typed), but it cannot be the significant member of a production. You can write for example <code>!@ W .&gt;&gt; X</code> (or <code>W.Extended().Append(X)</code> in C#), but not <code>!@ W .&gt;&gt;. X</code> (or <code>W.Extended().Extend(X)</code>).</p>
<blockquote>
<p>If you don't remember how to use an API from C#, <a href="csharp.html">this guide</a> can help you.</p>
</blockquote>
<p>The nonterminals use a slightly different approach. Let's see how we would write the nonterminal that recognizes the balanced parentheses:</p>
<p><strong>F#:</strong></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">S</span> <span class="o">=</span> <span class="id">nonterminalU</span> <span class="s">&quot;S&quot;</span>

<span class="id">S</span><span class="pn">.</span><span class="id">SetProductions</span><span class="pn">(</span>
    <span class="id">ProductionBuilder</span><span class="pn">(</span><span class="id">S</span><span class="pn">,</span> <span class="s">&quot;(&quot;</span><span class="pn">,</span> <span class="id">S</span><span class="pn">,</span> <span class="s">&quot;)&quot;</span><span class="pn">)</span><span class="pn">,</span>
    <span class="id">empty</span>
<span class="pn">)</span>
</code></pre></td>
</tr>
</table>
<p><strong>C#:</strong></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="csharp"><span class="k">var</span> S <span class="o">=</span> Nonterminal.CreateUntyped(<span class="s">"S"</span>);

S.SetProductions(
    <span class="k">new</span> ProductionBuilder(S, <span class="s">"("</span>, S, <span class="s">")"</span>),
    ProductionBuilder.Empty
);
</code></pre></td></tr></table>
<p>Let's take a closer look. The <code>ProductionBuilder</code>'s constructor accepts a variable amount of objects (or none, but this is essentially the empty one). You can pass designtime Farkles to be used in the resulting production as they are, or strings or characters to be used as literals. To avoid boxing, it's better to not pass characters at all, but not prohibited. If you pass any other type, an exception will be thrown. <code>S</code> is of type <code>Farkle.Builder.Untyped.Nonterminal</code>, which implements only the untyped <code>DesigntimeFarkle</code> interface.</p>
<p>In F#, instead of the last fourth line, we could have used the much terser <code>!% S .&gt;&gt; "(" .&gt;&gt; S .&gt;&gt; ")"</code>, but unfortunately, it wouldn't work due to <a href="https://github.com/dotnet/fsharp/issues/7917">a nasty and totally unexplained compiler bug</a>. This guide will be updated when the bug gets fixed.</p>
<p>Let's take a look at a different example. consider this F# designtime Farkle:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">number</span> <span class="o">=</span> <span class="id">Terminals</span><span class="pn">.</span><span class="id">uint32</span> <span class="s">&quot;Number&quot;</span>

<span class="k">let</span> <span class="id">adder</span> <span class="o">=</span> <span class="s">&quot;Add&quot;</span> <span class="o">||=</span> <span class="pn">[</span><span class="o">!@</span> <span class="id">number</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;+&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span class="id">number</span> <span class="o">=&gt;</span> <span class="pn">(</span><span class="o">+</span><span class="pn">)</span><span class="pn">]</span>
</code></pre></td>
</tr>
</table>
<p>It does exactly what you think it does. Gets a string of the form <code>X + Y</code>, and returns an unsigned integer containing their sum.</p>
<p>A grammar that recognizes the same language without returning anything can be defined like this:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">number</span> <span class="o">=</span> <span class="id">Terminals</span><span class="pn">.</span><span class="id">uint32</span> <span class="s">&quot;Number&quot;</span>

<span class="k">let</span> <span class="id">adder</span> <span class="o">=</span> <span class="s">&quot;Add&quot;</span> <span class="o">|||=</span> <span class="pn">[</span><span class="id">ProductionBuilder</span><span class="pn">(</span><span class="id">number</span><span class="pn">,</span> <span class="s">&quot;+&quot;</span><span class="pn">,</span> <span class="id">number</span><span class="pn">)</span><span class="pn">]</span>
</code></pre></td>
</tr>
</table>
<p>The difference above is in the operator in the last line. In C# we can do the same thing like that:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">DesigntimeFarkle&lt;<span class="k">uint</span>&gt; Number <span class="o">=</span> Terminals.UInt<span class="n">32</span>(<span class="s">"Number"</span>);
DesigntimeFarkle Adder <span class="o">=</span> Nonterminal.CreateUntyped(<span class="s">"Adder"</span>, <span class="k">new</span> ProductionBuilder(Number, <span class="s">"+"</span>, Number))
</code></pre></td></tr></table>
<p>Let's take a look now at how to actually use these untyped designtime Farkles. It's actually surprisingly simple, and can be done this way:</p>
<p><strong>F#:</strong></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// This is of type `RuntimeFarkle&lt;unit&gt;`.</span>
<span class="k">let</span> <span class="id">adderRuntime</span> <span class="o">=</span> <span class="id">RuntimeFarkle</span><span class="pn">.</span><span class="id">buildUntyped</span> <span class="id">adder</span>
</code></pre></td>
</tr>
</table>
<p><strong>C#:</strong></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="csharp"><span class="c">// The object it returns will always be null.</span>
RuntimeFarkle&lt;<span class="k">object</span>&gt; AdderRuntime <span class="o">=</span> Adder.BuildUntyped();
</code></pre></td></tr></table>
<p><code>buildUntyped</code> creates a <code>RuntimeFarkle</code> that does not return anything meaningful, and succeeds if the input text is valid.</p>
<h2><a name="Syntax-checking" class="anchor" href="#Syntax-checking">Syntax checking</a></h2>
<p>It is sometimes useful to just check if a string is syntactically valid, instead of giving it a meaning by returning an object out of it.</p>
<p>This is what the untyped API does, and we can call <code>buildUntyped</code> on a typed designtime Farkle to achieve the same.</p>
<p>Because building a designtime Farkle is expensive, if we already have a runtime Farkle, we can create a new one with the same grammar, but with a post-processor that does nothing. This post-processor is called a <em>syntax checker</em>. We can change the post-processor of a runtime Farkle this way:</p>
<p><strong>F#:</strong></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">open</span> <span class="id">Farkle</span><span class="pn">.</span><span class="id">PostProcessor</span>

<span class="k">let</span> <span class="id">designtime</span><span class="pn">:</span> <span class="id">DesigntimeFarkle</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">int</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="id">foo</span><span class="pn">(</span><span class="pn">)</span>

<span class="k">let</span> <span class="id">runtime</span><span class="pn">:</span> <span class="id">RuntimeFarkle</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs1', 2)" onmouseover="showTip(event, 'fs1', 2)" class="id">int</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="id">RuntimeFarkle</span><span class="pn">.</span><span class="id">build</span> <span class="id">designtime</span>

<span class="c">// syntaxChecker is of type RuntimeFarkle&lt;unit&gt;.</span>
<span class="k">let</span> <span class="id">syntaxCheck</span> <span class="o">=</span> <span class="id">RuntimeFarkle</span><span class="pn">.</span><span class="id">changePostProcessor</span> <span class="id">PostProcessors</span><span class="pn">.</span><span class="id">syntaxCheck</span> <span class="id">runtime</span>
</code></pre></td>
</tr>
</table>
<p><strong>C#:</strong></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="csharp">DesigntimeFarkle&lt;<span class="k">int</span>&gt; Designtime <span class="o">=</span> Foo();

RuntimeFarkle&lt;<span class="k">int</span>&gt; Runtime <span class="o">=</span> Designtime.Build();

RuntimeFarkle&lt;<span class="k">object</span>&gt; SyntaxCheck <span class="o">=</span> Runtime.SyntaxCheck();
<span class="c">// or</span>
RuntimeFarkle&lt;Unit&gt; SyntaxCheck <span class="o">=</span> Runtime.ChangePostProcessor(PostProcessors.SyntaxChecker);
</code></pre></td></tr></table>
<p>Changing the post-processor is extremely cheap; no new grammar objects are created, and the syntax-checking post-processor is the same.</p>
<blockquote>
<p>Actually, the post-processor used in both the F# and the C# example is the same object too. Post-processors are <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/">covariant</a> like designtime Farkles, because they are interfaces. Runtime Farkles on the other hand are classes and therefore not variant at all.</p>
</blockquote>
<hr />
<p>Farkle has more APIs for various little features that would make this document too lengthy. Fortunately, <a href="reference/index.html">they are well-documented in this site</a>, as well as while you code.</p>
<p>So, I hope you enjoyed this little guide. If you did, don't forget to give Farkle a try, and maybe you feel especially untyped today, and want to hit the star button as well. I hope that all of you have a wonderful day, and to see you soon. Goodbye!</p>

<div class="tip" id="fs1">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />--------------------<br />type int = int32<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int</div>

        </div>
        <div class="span3">
          <img src="/Farkle/img/logo.png" alt="F# Project" style="width:150px;margin:10px" />
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">Farkle</li>
            <li><a href="/Farkle/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="https://nuget.org/packages/Farkle">Get Library via NuGet</a></li>
            <li><a href="https://github.com/teo-tsirpanis/Farkle">Source Code on GitHub</a></li>
            <li><a href="/Farkle/license.html">License</a></li>
            <li><a href="/Farkle/release-notes.html">Release Notes</a></li>
            <li><a href="/Farkle/choosing-a-parser.html">Choosing a parser: Farkle vs alternatives</a></li>

            <li class="nav-header">Getting started</li>
            <li><a href="/Farkle/quickstart.html">Quick Start with F#</a></li>
            <li><a href="/Farkle/csharp.html">Using Farkle with C#</a></li>

            <li class="nav-header">Documentation</li>
            <li><a href="/Farkle/reference/index.html">API Reference</a></li>
            <li><a href="/Farkle/templates.html">Templating Reference</a></li>
            <li><a href="/Farkle/string-regexes.html">String regex reference</a></li>
            <li><a href="/Farkle/the-precompiler.html">The precompiler</a></li>
            <li><a href="/Farkle/advanced-features.html">Advanced Features</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="https://github.com/teo-tsirpanis/Farkle" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  </body>
</html>
