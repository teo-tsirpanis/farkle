<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Missing Features from GOLD Parser
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="A modern and easy-to-use parser library for F#"/>
    <meta name="author" content="Theodore Tsirpanis"/>

    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js" async></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="https://stackpath.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet" integrity="sha384-4FeI0trTH/PCsLWrGCD1mScoFu9Jf2NdknFdFoJhXZFwsvzZ3Bo5sAh7+zL8Xgnd" crossorigin="anonymous">

    <link type="text/css" rel="stylesheet" href="/Farkle/content/style.css" />
    <script type="text/javascript" src="/Farkle/content/tips.js" async></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="https://github.com/teo-tsirpanis/Farkle">github page</a></li>
        </ul>
        <h3 class="muted"><a href="/Farkle/index.html">Farkle</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          
<h1><a name="Missing-Features-from-GOLD-Parser" class="anchor" href="#Missing-Features-from-GOLD-Parser">Missing Features from GOLD Parser</a></h1>
<p>When Farkle started being developed, it was an engine for GOLD Parser, as it still is. However, as it evolved, its architecture started diverging from the other engines. As a consequence, some of the lesser used and known things that GOLD Parser allowed are not allowed in Farkle. In this document, we are going to take a look at these things, and what to do about them.</p>
<p>So, are we ready? Let's do this!</p>
<h2><a name="Virtual-Terminals" class="anchor" href="#Virtual-Terminals">Virtual Terminals</a></h2>
<p>When GOLD Parser's version 2.2 was released, back in 2004, one of its new features was the so-called "Virtual Terminals". So, what are these? A virtual terminal is a terminal that does not come from the engine's tokenizer, but from the user code that interacts with the engine. A connon use for virtual terminals is a parser for a language like Python. As you might have known, Python does not use keywords to define blocks of code, but instead uses indentation; the so-called "off-side rule". With virtual terminals, you could have written a grammar like this one:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;Start Symbol&quot;</span> <span class="o">=</span> <span class="pn">&lt;</span><span class="id">Code</span> <span class="id">Block</span><span class="pn">&gt;</span>

<span class="id">IndentStart</span> <span class="id">@=</span> <span class="pn">{</span><span class="id">Source</span> <span class="o">=</span> <span class="id">Virtual</span><span class="pn">}</span>
<span class="id">IndentStart</span> <span class="o">=</span> <span class="s">&#39; &#39;</span>
<span class="id">IndentEnd</span> <span class="id">@=</span> <span class="pn">{</span><span class="id">Source</span> <span class="o">=</span> <span class="id">Virtual</span><span class="pn">}</span>
<span class="id">IndentEnd</span> <span class="o">=</span> <span class="s">&#39; &#39;</span>
<span class="id">Number</span> <span class="o">=</span> <span class="pn">{</span><span class="id">Number</span><span class="pn">}</span><span class="o">+</span>

<span class="pn">&lt;</span><span class="id">Code</span> <span class="id">Block</span><span class="pn">&gt;</span> <span class="o">::</span><span class="o">=</span> <span class="id">IndentStart</span> <span class="pn">&lt;</span><span class="id">Code</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">Array</span><span class="pn">&gt;</span> <span class="id">IndentEnd</span>
<span class="pn">&lt;</span><span class="id">Code</span> <span onmouseout="hideTip(event, 'fs1', 2)" onmouseover="showTip(event, 'fs1', 2)" class="id">Array</span><span class="pn">&gt;</span> <span class="o">::</span><span class="o">=</span> <span class="pn">&lt;</span><span class="id">Code</span><span class="pn">&gt;</span> <span class="pn">&lt;</span><span class="id">Code</span> <span onmouseout="hideTip(event, 'fs1', 3)" onmouseover="showTip(event, 'fs1', 3)" class="id">Array</span><span class="pn">&gt;</span> <span class="pn">|</span> <span class="pn">&lt;</span><span class="id">Code</span><span class="pn">&gt;</span>
<span class="pn">&lt;</span><span class="id">Code</span><span class="pn">&gt;</span> <span class="o">::</span><span class="o">=</span> <span class="pn">&lt;</span><span class="id">Numbers</span><span class="pn">&gt;</span> <span class="pn">|</span> <span class="pn">&lt;</span><span class="id">Code</span> <span class="id">Block</span><span class="pn">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>This grammar is surprisingly simple. Its language consists of lists of numbers, which can be infinitely nested into sublists.</p>
<p>When you write the code to parse this grammar, you will create an <code>IndentStart</code> token every time you see that the indentation at the beginning has increased, and the other way around with <code>IndentEnd</code>.</p>
<p>Unfortunately, Farkle does not support virtual terminals. It's architecture does not allow you to generate tokens from a place different than the tokenizer.</p>
<p>However, as I was typing the above paragraph, I remembered something. Farkle's parser and tokenizer are completely decoupled, which allows you to write your own tokenizer which hooks into the real one.</p>
<p>Unfortunately, as I was trying to write a custom tokenizer for this grammar, i realized that it was extremely hard to make it correctly work. Farkle was not designed with virtual terminals in mind, yet I understand that this is an important feature to have. It <em>is</em>, <strong>theoretically</strong> possible to do it, but practically cubersome. If you have any solution to this problem, you can send it in a pull request and I would be happy to see it.</p>
<h2><a name="Group-End-Symbols-in-Productions" class="anchor" href="#Group-End-Symbols-in-Productions">Group End Symbols in Productions</a></h2>
<p>The next GOLD Parser feature that is supported by Farkle is quite the bizzare one. But let's see an example first in another little grammar:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="id">Comment</span> <span class="id">Start</span> <span class="o">=</span> <span class="id">&#39;</span><span class="o">/*</span><span class="id">&#39;</span>
<span class="id">Comment</span> <span class="id">End</span> <span class="o">=</span> <span class="id">&#39;</span><span class="o">*/</span><span class="id">&#39;</span>

<span class="s">&quot;Start Symbol&quot;</span> <span class="o">=</span> <span class="pn">&lt;</span><span class="id">S</span><span class="pn">&gt;</span>

<span class="pn">&lt;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="o">::</span><span class="o">=</span> <span class="id">&#39;</span><span class="id">hello&#39;</span> <span class="pn">|</span> <span class="id">&#39;</span><span class="o">/*</span><span class="id">&#39;</span>
</code></pre></td>
</tr>
</table>
<p>The grammar's language is either the string <code>hello</code>, or the string <code>/*</code>, which also starts a comment. When you try to build this grammar in GOLD Parser, it will raise an error. The reason is surprisingly simple. If you parse a <code>/*</code>, the tokenizer will start a <code>Comment</code> group, unable to recognize that this is not what it sould do.</p>
<p>But if you replace the last line with this one?</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">&lt;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="o">::</span><span class="o">=</span> <span class="id">&#39;</span><span class="id">hello&#39;</span> <span class="pn">|</span> <span class="id">&#39;</span><span class="o">*/</span><span class="id">&#39;</span>
</code></pre></td>
</tr>
</table>
<p>Instead of the comment start symbol, we 've got a comment <em>end</em> symbol. Surprisingly, GOLD Parser would now build the grammar without a problem. And when we parse the string <code>*/</code>, the tokenizer would be able to recignize it - if we are outside of a comment of course - and will happily parse it. Hooray!</p>
<p>But Farkle, unfortunately, is not feeling the same. Historically, all GOLD Parser engines had one object type called symbol. This symbol, could be a terminal, a nonterminal, a noise symbol, a group starting symbol, a group ending symbol, and other things that did not make any sense. For example, the lexical error was represented by actual tokens that had a special symbol on their own, and so did the end of input.</p>
<p>While this approach was kept things simple, it was extremely type-unsafe. It allowed for example tokenizers to produce nonterminals, which does not happen in reality.</p>
<p>That's why Farkle took a much more strongly-typed approach starting from version 4.0.0, when the grammar types were rewritten from scratch without any inspiration from other GOLD Parser engines. After that, a tokenizer can <em>only</em> output a terminal, a noise symbol and a group start/end symbol. Similary, productions are <em>only</em> made of a nonterminal head symbol and a handle of terminals and nonterminals, a transformer can be declared only for terminals, and so on. Any EGT file that tried to do something else was considered invalid. This change was definitely the best option, and paved the way for much safer and expressive code.</p>
<p>Now, as I have said before, starting from Farkle 4.0.0, a production's handle is made of a list of terminals and nonterminals. Allowing group end symbols in this closed group would significantly alter Farkle's architecture and would pose some new problems, like whether to make transformers support group end symbols as well. And allowing them would seem asymmetrical, given that group start symbols are understandably not allowed.</p>
<p>In the end, group end symbols are confined to their ascribed fate: to end groups. Any EGT file that has productions with group end symbols will be considered invalid, and a special error will be generated to explain this unfortunate situation.</p>
<hr />
<p>So, I hope you enjoyed this little document. If you did, don't forget to give Farkle a try, and maybe you feel especially GOLD today, and want to hit the star button as well. I hope that all of you have a wonderful day, and to see you soon. Goodbye!</p>

<div class="tip" id="fs1">module Array<br /><br />from Microsoft.FSharp.Collections</div>

        </div>
        <div class="span3">
          <img src="/Farkle/img/logo.png" alt="F# Project" style="width:150px;margin:10px" />
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">Farkle</li>
            <li><a href="/Farkle/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="http://nuget.org/packages/Farkle">Get Library via NuGet</a></li>
            <li><a href="https://github.com/teo-tsirpanis/Farkle">Source Code on GitHub</a></li>
            <li><a href="/Farkle/license.html">License</a></li>
            <li><a href="/Farkle/release-notes.html">Release Notes</a></li>

            <li class="nav-header">Getting started</li>
            <li><a href="/Farkle/quickstart.html">Quick Start with F#</a></li>
            <li><a href="/Farkle/csharp.html">Using Farkle with C#</a></li>

            <li class="nav-header">Documentation</li>
            <li><a href="/Farkle/reference/index.html">API Reference</a></li>
            <li><a href="/Farkle/templates.html">Templating Reference</a></li>
            <li><a href="/Farkle/gold-parser-missing-features.html">Missing Features from GOLD Parser</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="https://github.com/teo-tsirpanis/Farkle" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  </body>
</html>
